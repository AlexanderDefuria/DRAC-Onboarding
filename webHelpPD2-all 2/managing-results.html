<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-01-14T21:03:21.019558"><title>Managing Results | Python DRAC</title><script type="application/json" id="virtual-toc-data">[{"id":"copying-files-to-nodes","level":0,"title":"Copying Files to Nodes","anchor":"#copying-files-to-nodes"},{"id":"outputting-results","level":0,"title":"Outputting Results","anchor":"#outputting-results"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Managing Results | Python DRAC"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Python DRAC Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/managing-results.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Managing Results | Python DRAC"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/managing-results.html#webpage",
    "url": "writerside-documentation/managing-results.html",
    "name": "Managing Results | Python DRAC",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Python DRAC Help"
}</script><!-- End Schema.org --></head><body data-id="Managing-Results" data-main-title="Managing Results" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Python DRAC  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Managing-Results" id="Managing-Results.md">Managing Results</h1><p id="-mymv0a_3">In the previous section we covered running python programs and saw some (largely) unstructured output in the <code class="code" id="-mymv0a_8">slurm-XXXXXX.out</code> file. For small amounts of output and data this can be more than fine. In cases where there is large amounts of output generated, especially non-textual data, this is clearly less than ideal. As such we can opt to output more complex files and data directly on the compute node, and copy them back to the login node when the computation is done.</p><p id="-mymv0a_4">One can also write directly back to the login node with output, similar to the log file but for arbitrary data. The benefit of this is that we can have periodic saving of results, the downside is that repeated writes will degrade performance and cause higher than under-utilization of the CPU. As a general rule of thumb the further the storage location from the compute node, the more overhead and waste of resources will occur.</p><p id="-mymv0a_5">Opinions on how to solve this problem may differ. This guide takes the stance that results should be periodically and repeated saved to the compute node storage, and at the end of program execution the results should be copied back to the login node (or elsewhere) for subsequent analysis and reliable storage.</p><section class="chapter"><h2 id="copying-files-to-nodes" data-toc="copying-files-to-nodes">Copying Files to Nodes</h2><p id="-mymv0a_9">The workload manager provides functionality to copy large numbers of files between login and compute nodes efficiently at both the start and end of the program. This takes place within the bash script passed to <code class="code" id="-mymv0a_12">sbatch</code>. In the context of a single or serial job no special command is required, in the context of an array job, files must be copied to and from multiple jobs, as such the <code class="code" id="-mymv0a_13">srun</code> command may be used. More information about multi-job setups can be found in the <a href="multiprocessing.html" id="-mymv0a_14" data-tooltip="Multiprocessing can be a massive improvement in computational efficiency. In many cases it is crucial to parallelize operations to complete tasks in a reasonable amount of time. It is also one of the main draws of the alliance HPC given the large number of high core-count CPU's…">Multiprocessing</a> section. More information about copying files can be found in the <a href="copying-files.html" id="-mymv0a_15" data-tooltip="Transferring files to and from Alliance clusters should be done through data transfer nodes (data movers) rather than login nodes for better performance and to avoid overloading login resources. If you need a secure and efficient way to move files from your personal computer, you…">Copying Files</a> section.</p><section class="chapter"><h3 id="single-job" data-toc="single-job">Single Job</h3><div class="code-block" data-lang="bash">
#!/bin/bash
#SBATCH --time=00:15:00
#... preamble ...
cp -r $HOME_DIR/some_dir $SLRUM_TMPDIR
#...Some Computation Here...
cp -r results/ $HOME_DIR/results
</div></section><section class="chapter"><h3 id="array-job" data-toc="array-job">Array Job</h3><div class="code-block" data-lang="bash">
#!/bin/bash
#SBATCH --time=00:15:00
#... preamble ...
srun --ntasks=$SLURM_NNODES --ntasks-per-node=1 cp -r $HOME_DIR/some_dir $SLRUM_TMPDIR
#... Some Computation Here ...
cp -r results/ $HOME_DIR/results/$SLURM_ARRAY_TASK_ID/
</div></section></section><section class="chapter"><h2 id="outputting-results" data-toc="outputting-results">Outputting Results</h2><p id="-mymv0a_18">In the previous subsection we showed how to copy files between compute and login nodes in both directions. In most cases you will have an output method that has already been functional for your purposes. In the case of single job projects this should not largely need to change if it is a significant burden but may still benefit from adjusting to a multiprocessing output paradigm, this will not be covered here but best practices are available elsewhere (avoiding of I/O locking and race conditions, and more).</p><p id="-mymv0a_19">Multinode jobs in particular pose a challenge as thy do not share a local filesystem, thus the appropriate input and output files must be copied between the compute and login nodes. This is shown <a href="#array-job" id="-mymv0a_20" data-tooltip="#!/bin/bash #SBATCH --time=00:15:00 #... preamble ... srun --ntasks=$SLURM_NNODES --ntasks-per-node=1 cp -r $HOME_DIR/some_dir $SLRUM_TMPDIR #... Some Computation Here ... cp -r results/ $HOME_DIR/results/$SLURM_ARRAY_TASK_ID/">here</a>. Dedicating some time to determine a simple file structure that can be joined easily without much subsequent computational effort will likely be beneficial later. Something as simple as maintaining a format across all files that can be concatenated or joining on some id. Creating a secondary job to do this might be beneficial.</p></section><div class="last-modified">Last modified: 15 January 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="monitoring-jobs.html" class="navigation-links__prev">Monitoring Jobs</a><a href="copying-files.html" class="navigation-links__next">Copying Files</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>